Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    DOT
    newline

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM COLON V MAIN P B END
Rule 2     MAIN -> empty
Rule 3     V -> V VAR VM COLON TIPO
Rule 4     V -> empty
Rule 5     VM -> ID VM2
Rule 6     VM2 -> COMMA ID VM2
Rule 7     VM2 -> empty
Rule 8     TIPO -> FLOAT
Rule 9     TIPO -> INT
Rule 10    TIPO -> ARRAY
Rule 11    TIPO -> MATRIX
Rule 12    TIPO -> CUBE
Rule 13    TIPO -> BOOL
Rule 14    P -> P AUXPOSP PROCEDURE ID COLON B ENDP
Rule 15    P -> empty
Rule 16    AUXPOSP -> empty
Rule 17    B -> BEGIN COLON ST
Rule 18    ST -> S ST
Rule 19    ST -> empty
Rule 20    S -> FOR ID IN ID COLON ST ENDF
Rule 21    S -> DO COLON ST DWHILE COLON CONDITION ENDDO
Rule 22    S -> GOSUB ID
Rule 23    S -> PRINT PARL SID PARR
Rule 24    SID -> STRING SID2
Rule 25    SID -> VMC SID2
Rule 26    SID2 -> PLUS VMC SID2
Rule 27    SID2 -> PLUS STRING SID2
Rule 28    SID2 -> empty
Rule 29    VMC -> ID
Rule 30    VMC -> ID SQBL CMP SQBR SQBL CMP SQBR
Rule 31    VMC -> ID SQBL CMP SQBR SQBL CMP SQBR SQBL CMP SQBR
Rule 32    CMP -> NUMBER
Rule 33    CMP -> ID
Rule 34    S -> INPUT PARL IID PARR
Rule 35    IID -> VMC IID2
Rule 36    IID2 -> COMMA VMC IID2
Rule 37    IID2 -> empty
Rule 38    S -> CMP ASSIGN UPDATE
Rule 39    UPDATE -> T
Rule 40    UPDATE -> UPDATE PLUS T
Rule 41    UPDATE -> UPDATE MINUS T
Rule 42    UPDATE -> UPDATE OR T
Rule 43    T -> F
Rule 44    T -> T TIMES F
Rule 45    T -> T DIVIDE F
Rule 46    T -> T AND F
Rule 47    F -> ID
Rule 48    F -> NUMBER
Rule 49    F -> PARL CONDITION PARR
Rule 50    S -> IF CONDITION AUXCOLON ST ENDIF
Rule 51    S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF
Rule 52    AUXQ -> empty
Rule 53    AUXENDIF -> empty
Rule 54    S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW
Rule 55    AUXWHILE -> empty
Rule 56    AUXENDWHILE -> empty
Rule 57    CONDITION -> UPDATE
Rule 58    CONDITION -> UPDATE NE UPDATE
Rule 59    CONDITION -> UPDATE GT UPDATE
Rule 60    CONDITION -> UPDATE LT UPDATE
Rule 61    CONDITION -> UPDATE EQ UPDATE
Rule 62    AUXCOLON -> COLON
Rule 63    empty -> <empty>

Terminals, with rules where they appear

AND                  : 46
ARRAY                : 10
ASSIGN               : 38
BEGIN                : 17
BOOL                 : 13
COLON                : 1 3 14 17 20 21 21 51 62
COMMA                : 6 36
COMMENT              : 
CUBE                 : 12
DIVIDE               : 45
DO                   : 21
DOT                  : 
DWHILE               : 21
ELSE                 : 51
END                  : 1
ENDDO                : 21
ENDF                 : 20
ENDIF                : 50 51
ENDP                 : 14
ENDW                 : 54
EQ                   : 61
FLOAT                : 8
FOR                  : 20
GOSUB                : 22
GT                   : 59
ID                   : 5 6 14 20 20 22 29 30 31 33 47
IF                   : 50 51
IN                   : 20
INPUT                : 34
INT                  : 9
LT                   : 60
MATRIX               : 11
MINUS                : 41
NE                   : 58
NUMBER               : 32 48
OR                   : 42
PARL                 : 23 34 49
PARR                 : 23 34 49
PLUS                 : 26 27 40
PRINT                : 23
PROCEDURE            : 14
PROGRAM              : 1
SQBL                 : 30 30 31 31 31
SQBR                 : 30 30 31 31 31
STRING               : 24 27
TIMES                : 44
VAR                  : 3
WHILE                : 54
error                : 
newline              : 

Nonterminals, with rules where they appear

AUXCOLON             : 50 51 54
AUXENDIF             : 51
AUXENDWHILE          : 54
AUXPOSP              : 14
AUXQ                 : 51
AUXWHILE             : 54
B                    : 1 14
CMP                  : 30 30 31 31 31 38
CONDITION            : 21 49 50 51 54
F                    : 43 44 45 46
IID                  : 34
IID2                 : 35 36
MAIN                 : 1
P                    : 1 14
S                    : 18
SID                  : 23
SID2                 : 24 25 26 27
ST                   : 17 18 20 21 50 51 51 54
T                    : 39 40 41 42 44 45 46
TIPO                 : 3
UPDATE               : 38 40 41 42 57 58 58 59 59 60 60 61 61
V                    : 1 3
VM                   : 3
VM2                  : 5 6
VMC                  : 25 26 35 36
empty                : 2 4 7 15 16 19 28 37 52 53 55 56
program              : 0

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM COLON V MAIN P B END

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . COLON V MAIN P B END

    COLON           shift and go to state 3


state 3

    (1) program -> PROGRAM COLON . V MAIN P B END
    (3) V -> . V VAR VM COLON TIPO
    (4) V -> . empty
    (63) empty -> .

    VAR             reduce using rule 63 (empty -> .)
    BEGIN           reduce using rule 63 (empty -> .)
    PROCEDURE       reduce using rule 63 (empty -> .)

    V                              shift and go to state 4
    empty                          shift and go to state 5

state 4

    (1) program -> PROGRAM COLON V . MAIN P B END
    (3) V -> V . VAR VM COLON TIPO
    (2) MAIN -> . empty
    (63) empty -> .

    VAR             shift and go to state 7
    BEGIN           reduce using rule 63 (empty -> .)
    PROCEDURE       reduce using rule 63 (empty -> .)

    MAIN                           shift and go to state 6
    empty                          shift and go to state 8

state 5

    (4) V -> empty .

    VAR             reduce using rule 4 (V -> empty .)
    BEGIN           reduce using rule 4 (V -> empty .)
    PROCEDURE       reduce using rule 4 (V -> empty .)


state 6

    (1) program -> PROGRAM COLON V MAIN . P B END
    (14) P -> . P AUXPOSP PROCEDURE ID COLON B ENDP
    (15) P -> . empty
    (63) empty -> .

    BEGIN           reduce using rule 63 (empty -> .)
    PROCEDURE       reduce using rule 63 (empty -> .)

    P                              shift and go to state 9
    empty                          shift and go to state 10

state 7

    (3) V -> V VAR . VM COLON TIPO
    (5) VM -> . ID VM2

    ID              shift and go to state 12

    VM                             shift and go to state 11

state 8

    (2) MAIN -> empty .

    BEGIN           reduce using rule 2 (MAIN -> empty .)
    PROCEDURE       reduce using rule 2 (MAIN -> empty .)


state 9

    (1) program -> PROGRAM COLON V MAIN P . B END
    (14) P -> P . AUXPOSP PROCEDURE ID COLON B ENDP
    (17) B -> . BEGIN COLON ST
    (16) AUXPOSP -> . empty
    (63) empty -> .

    BEGIN           shift and go to state 15
    PROCEDURE       reduce using rule 63 (empty -> .)

    B                              shift and go to state 13
    AUXPOSP                        shift and go to state 14
    empty                          shift and go to state 16

state 10

    (15) P -> empty .

    BEGIN           reduce using rule 15 (P -> empty .)
    PROCEDURE       reduce using rule 15 (P -> empty .)


state 11

    (3) V -> V VAR VM . COLON TIPO

    COLON           shift and go to state 17


state 12

    (5) VM -> ID . VM2
    (6) VM2 -> . COMMA ID VM2
    (7) VM2 -> . empty
    (63) empty -> .

    COMMA           shift and go to state 19
    COLON           reduce using rule 63 (empty -> .)

    VM2                            shift and go to state 18
    empty                          shift and go to state 20

state 13

    (1) program -> PROGRAM COLON V MAIN P B . END

    END             shift and go to state 21


state 14

    (14) P -> P AUXPOSP . PROCEDURE ID COLON B ENDP

    PROCEDURE       shift and go to state 22


state 15

    (17) B -> BEGIN . COLON ST

    COLON           shift and go to state 23


state 16

    (16) AUXPOSP -> empty .

    PROCEDURE       reduce using rule 16 (AUXPOSP -> empty .)


state 17

    (3) V -> V VAR VM COLON . TIPO
    (8) TIPO -> . FLOAT
    (9) TIPO -> . INT
    (10) TIPO -> . ARRAY
    (11) TIPO -> . MATRIX
    (12) TIPO -> . CUBE
    (13) TIPO -> . BOOL

    FLOAT           shift and go to state 25
    INT             shift and go to state 26
    ARRAY           shift and go to state 27
    MATRIX          shift and go to state 28
    CUBE            shift and go to state 29
    BOOL            shift and go to state 30

    TIPO                           shift and go to state 24

state 18

    (5) VM -> ID VM2 .

    COLON           reduce using rule 5 (VM -> ID VM2 .)


state 19

    (6) VM2 -> COMMA . ID VM2

    ID              shift and go to state 31


state 20

    (7) VM2 -> empty .

    COLON           reduce using rule 7 (VM2 -> empty .)


state 21

    (1) program -> PROGRAM COLON V MAIN P B END .

    $end            reduce using rule 1 (program -> PROGRAM COLON V MAIN P B END .)


state 22

    (14) P -> P AUXPOSP PROCEDURE . ID COLON B ENDP

    ID              shift and go to state 32


state 23

    (17) B -> BEGIN COLON . ST
    (18) ST -> . S ST
    (19) ST -> . empty
    (20) S -> . FOR ID IN ID COLON ST ENDF
    (21) S -> . DO COLON ST DWHILE COLON CONDITION ENDDO
    (22) S -> . GOSUB ID
    (23) S -> . PRINT PARL SID PARR
    (34) S -> . INPUT PARL IID PARR
    (38) S -> . CMP ASSIGN UPDATE
    (50) S -> . IF CONDITION AUXCOLON ST ENDIF
    (51) S -> . IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF
    (54) S -> . WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW
    (63) empty -> .
    (32) CMP -> . NUMBER
    (33) CMP -> . ID

    FOR             shift and go to state 36
    DO              shift and go to state 38
    GOSUB           shift and go to state 39
    PRINT           shift and go to state 40
    INPUT           shift and go to state 41
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    END             reduce using rule 63 (empty -> .)
    ENDP            reduce using rule 63 (empty -> .)
    NUMBER          shift and go to state 45
    ID              shift and go to state 37

    ST                             shift and go to state 33
    S                              shift and go to state 34
    empty                          shift and go to state 35
    CMP                            shift and go to state 42

state 24

    (3) V -> V VAR VM COLON TIPO .

    VAR             reduce using rule 3 (V -> V VAR VM COLON TIPO .)
    BEGIN           reduce using rule 3 (V -> V VAR VM COLON TIPO .)
    PROCEDURE       reduce using rule 3 (V -> V VAR VM COLON TIPO .)


state 25

    (8) TIPO -> FLOAT .

    VAR             reduce using rule 8 (TIPO -> FLOAT .)
    BEGIN           reduce using rule 8 (TIPO -> FLOAT .)
    PROCEDURE       reduce using rule 8 (TIPO -> FLOAT .)


state 26

    (9) TIPO -> INT .

    VAR             reduce using rule 9 (TIPO -> INT .)
    BEGIN           reduce using rule 9 (TIPO -> INT .)
    PROCEDURE       reduce using rule 9 (TIPO -> INT .)


state 27

    (10) TIPO -> ARRAY .

    VAR             reduce using rule 10 (TIPO -> ARRAY .)
    BEGIN           reduce using rule 10 (TIPO -> ARRAY .)
    PROCEDURE       reduce using rule 10 (TIPO -> ARRAY .)


state 28

    (11) TIPO -> MATRIX .

    VAR             reduce using rule 11 (TIPO -> MATRIX .)
    BEGIN           reduce using rule 11 (TIPO -> MATRIX .)
    PROCEDURE       reduce using rule 11 (TIPO -> MATRIX .)


state 29

    (12) TIPO -> CUBE .

    VAR             reduce using rule 12 (TIPO -> CUBE .)
    BEGIN           reduce using rule 12 (TIPO -> CUBE .)
    PROCEDURE       reduce using rule 12 (TIPO -> CUBE .)


state 30

    (13) TIPO -> BOOL .

    VAR             reduce using rule 13 (TIPO -> BOOL .)
    BEGIN           reduce using rule 13 (TIPO -> BOOL .)
    PROCEDURE       reduce using rule 13 (TIPO -> BOOL .)


state 31

    (6) VM2 -> COMMA ID . VM2
    (6) VM2 -> . COMMA ID VM2
    (7) VM2 -> . empty
    (63) empty -> .

    COMMA           shift and go to state 19
    COLON           reduce using rule 63 (empty -> .)

    VM2                            shift and go to state 46
    empty                          shift and go to state 20

state 32

    (14) P -> P AUXPOSP PROCEDURE ID . COLON B ENDP

    COLON           shift and go to state 47


state 33

    (17) B -> BEGIN COLON ST .

    END             reduce using rule 17 (B -> BEGIN COLON ST .)
    ENDP            reduce using rule 17 (B -> BEGIN COLON ST .)


state 34

    (18) ST -> S . ST
    (18) ST -> . S ST
    (19) ST -> . empty
    (20) S -> . FOR ID IN ID COLON ST ENDF
    (21) S -> . DO COLON ST DWHILE COLON CONDITION ENDDO
    (22) S -> . GOSUB ID
    (23) S -> . PRINT PARL SID PARR
    (34) S -> . INPUT PARL IID PARR
    (38) S -> . CMP ASSIGN UPDATE
    (50) S -> . IF CONDITION AUXCOLON ST ENDIF
    (51) S -> . IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF
    (54) S -> . WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW
    (63) empty -> .
    (32) CMP -> . NUMBER
    (33) CMP -> . ID

    FOR             shift and go to state 36
    DO              shift and go to state 38
    GOSUB           shift and go to state 39
    PRINT           shift and go to state 40
    INPUT           shift and go to state 41
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    END             reduce using rule 63 (empty -> .)
    ENDP            reduce using rule 63 (empty -> .)
    DWHILE          reduce using rule 63 (empty -> .)
    ENDIF           reduce using rule 63 (empty -> .)
    ELSE            reduce using rule 63 (empty -> .)
    ENDW            reduce using rule 63 (empty -> .)
    ENDF            reduce using rule 63 (empty -> .)
    NUMBER          shift and go to state 45
    ID              shift and go to state 37

    S                              shift and go to state 34
    ST                             shift and go to state 48
    empty                          shift and go to state 35
    CMP                            shift and go to state 42

state 35

    (19) ST -> empty .

    END             reduce using rule 19 (ST -> empty .)
    ENDP            reduce using rule 19 (ST -> empty .)
    DWHILE          reduce using rule 19 (ST -> empty .)
    ENDIF           reduce using rule 19 (ST -> empty .)
    ELSE            reduce using rule 19 (ST -> empty .)
    ENDW            reduce using rule 19 (ST -> empty .)
    ENDF            reduce using rule 19 (ST -> empty .)


state 36

    (20) S -> FOR . ID IN ID COLON ST ENDF

    ID              shift and go to state 49


state 37

    (33) CMP -> ID .

    ASSIGN          reduce using rule 33 (CMP -> ID .)
    SQBR            reduce using rule 33 (CMP -> ID .)


state 38

    (21) S -> DO . COLON ST DWHILE COLON CONDITION ENDDO

    COLON           shift and go to state 50


state 39

    (22) S -> GOSUB . ID

    ID              shift and go to state 51


state 40

    (23) S -> PRINT . PARL SID PARR

    PARL            shift and go to state 52


state 41

    (34) S -> INPUT . PARL IID PARR

    PARL            shift and go to state 53


state 42

    (38) S -> CMP . ASSIGN UPDATE

    ASSIGN          shift and go to state 54


state 43

    (50) S -> IF . CONDITION AUXCOLON ST ENDIF
    (51) S -> IF . CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF
    (57) CONDITION -> . UPDATE
    (58) CONDITION -> . UPDATE NE UPDATE
    (59) CONDITION -> . UPDATE GT UPDATE
    (60) CONDITION -> . UPDATE LT UPDATE
    (61) CONDITION -> . UPDATE EQ UPDATE
    (39) UPDATE -> . T
    (40) UPDATE -> . UPDATE PLUS T
    (41) UPDATE -> . UPDATE MINUS T
    (42) UPDATE -> . UPDATE OR T
    (43) T -> . F
    (44) T -> . T TIMES F
    (45) T -> . T DIVIDE F
    (46) T -> . T AND F
    (47) F -> . ID
    (48) F -> . NUMBER
    (49) F -> . PARL CONDITION PARR

    ID              shift and go to state 59
    NUMBER          shift and go to state 60
    PARL            shift and go to state 61

    CONDITION                      shift and go to state 55
    UPDATE                         shift and go to state 56
    T                              shift and go to state 57
    F                              shift and go to state 58

state 44

    (54) S -> WHILE . AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW
    (55) AUXWHILE -> . empty
    (63) empty -> .

    ID              reduce using rule 63 (empty -> .)
    NUMBER          reduce using rule 63 (empty -> .)
    PARL            reduce using rule 63 (empty -> .)

    AUXWHILE                       shift and go to state 62
    empty                          shift and go to state 63

state 45

    (32) CMP -> NUMBER .

    ASSIGN          reduce using rule 32 (CMP -> NUMBER .)
    SQBR            reduce using rule 32 (CMP -> NUMBER .)


state 46

    (6) VM2 -> COMMA ID VM2 .

    COLON           reduce using rule 6 (VM2 -> COMMA ID VM2 .)


state 47

    (14) P -> P AUXPOSP PROCEDURE ID COLON . B ENDP
    (17) B -> . BEGIN COLON ST

    BEGIN           shift and go to state 15

    B                              shift and go to state 64

state 48

    (18) ST -> S ST .

    END             reduce using rule 18 (ST -> S ST .)
    ENDP            reduce using rule 18 (ST -> S ST .)
    DWHILE          reduce using rule 18 (ST -> S ST .)
    ENDIF           reduce using rule 18 (ST -> S ST .)
    ELSE            reduce using rule 18 (ST -> S ST .)
    ENDW            reduce using rule 18 (ST -> S ST .)
    ENDF            reduce using rule 18 (ST -> S ST .)


state 49

    (20) S -> FOR ID . IN ID COLON ST ENDF

    IN              shift and go to state 65


state 50

    (21) S -> DO COLON . ST DWHILE COLON CONDITION ENDDO
    (18) ST -> . S ST
    (19) ST -> . empty
    (20) S -> . FOR ID IN ID COLON ST ENDF
    (21) S -> . DO COLON ST DWHILE COLON CONDITION ENDDO
    (22) S -> . GOSUB ID
    (23) S -> . PRINT PARL SID PARR
    (34) S -> . INPUT PARL IID PARR
    (38) S -> . CMP ASSIGN UPDATE
    (50) S -> . IF CONDITION AUXCOLON ST ENDIF
    (51) S -> . IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF
    (54) S -> . WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW
    (63) empty -> .
    (32) CMP -> . NUMBER
    (33) CMP -> . ID

    FOR             shift and go to state 36
    DO              shift and go to state 38
    GOSUB           shift and go to state 39
    PRINT           shift and go to state 40
    INPUT           shift and go to state 41
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    DWHILE          reduce using rule 63 (empty -> .)
    NUMBER          shift and go to state 45
    ID              shift and go to state 37

    ST                             shift and go to state 66
    S                              shift and go to state 34
    empty                          shift and go to state 35
    CMP                            shift and go to state 42

state 51

    (22) S -> GOSUB ID .

    FOR             reduce using rule 22 (S -> GOSUB ID .)
    DO              reduce using rule 22 (S -> GOSUB ID .)
    GOSUB           reduce using rule 22 (S -> GOSUB ID .)
    PRINT           reduce using rule 22 (S -> GOSUB ID .)
    INPUT           reduce using rule 22 (S -> GOSUB ID .)
    IF              reduce using rule 22 (S -> GOSUB ID .)
    WHILE           reduce using rule 22 (S -> GOSUB ID .)
    NUMBER          reduce using rule 22 (S -> GOSUB ID .)
    ID              reduce using rule 22 (S -> GOSUB ID .)
    END             reduce using rule 22 (S -> GOSUB ID .)
    ENDP            reduce using rule 22 (S -> GOSUB ID .)
    DWHILE          reduce using rule 22 (S -> GOSUB ID .)
    ENDIF           reduce using rule 22 (S -> GOSUB ID .)
    ELSE            reduce using rule 22 (S -> GOSUB ID .)
    ENDW            reduce using rule 22 (S -> GOSUB ID .)
    ENDF            reduce using rule 22 (S -> GOSUB ID .)


state 52

    (23) S -> PRINT PARL . SID PARR
    (24) SID -> . STRING SID2
    (25) SID -> . VMC SID2
    (29) VMC -> . ID
    (30) VMC -> . ID SQBL CMP SQBR SQBL CMP SQBR
    (31) VMC -> . ID SQBL CMP SQBR SQBL CMP SQBR SQBL CMP SQBR

    STRING          shift and go to state 68
    ID              shift and go to state 70

    SID                            shift and go to state 67
    VMC                            shift and go to state 69

state 53

    (34) S -> INPUT PARL . IID PARR
    (35) IID -> . VMC IID2
    (29) VMC -> . ID
    (30) VMC -> . ID SQBL CMP SQBR SQBL CMP SQBR
    (31) VMC -> . ID SQBL CMP SQBR SQBL CMP SQBR SQBL CMP SQBR

    ID              shift and go to state 70

    IID                            shift and go to state 71
    VMC                            shift and go to state 72

state 54

    (38) S -> CMP ASSIGN . UPDATE
    (39) UPDATE -> . T
    (40) UPDATE -> . UPDATE PLUS T
    (41) UPDATE -> . UPDATE MINUS T
    (42) UPDATE -> . UPDATE OR T
    (43) T -> . F
    (44) T -> . T TIMES F
    (45) T -> . T DIVIDE F
    (46) T -> . T AND F
    (47) F -> . ID
    (48) F -> . NUMBER
    (49) F -> . PARL CONDITION PARR

    ID              shift and go to state 59
    NUMBER          shift and go to state 60
    PARL            shift and go to state 61

    UPDATE                         shift and go to state 73
    T                              shift and go to state 57
    F                              shift and go to state 58

state 55

    (50) S -> IF CONDITION . AUXCOLON ST ENDIF
    (51) S -> IF CONDITION . AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF
    (62) AUXCOLON -> . COLON

    COLON           shift and go to state 75

    AUXCOLON                       shift and go to state 74

state 56

    (57) CONDITION -> UPDATE .
    (58) CONDITION -> UPDATE . NE UPDATE
    (59) CONDITION -> UPDATE . GT UPDATE
    (60) CONDITION -> UPDATE . LT UPDATE
    (61) CONDITION -> UPDATE . EQ UPDATE
    (40) UPDATE -> UPDATE . PLUS T
    (41) UPDATE -> UPDATE . MINUS T
    (42) UPDATE -> UPDATE . OR T

    COLON           reduce using rule 57 (CONDITION -> UPDATE .)
    PARR            reduce using rule 57 (CONDITION -> UPDATE .)
    ENDDO           reduce using rule 57 (CONDITION -> UPDATE .)
    NE              shift and go to state 76
    GT              shift and go to state 77
    LT              shift and go to state 78
    EQ              shift and go to state 79
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    OR              shift and go to state 82


state 57

    (39) UPDATE -> T .
    (44) T -> T . TIMES F
    (45) T -> T . DIVIDE F
    (46) T -> T . AND F

    NE              reduce using rule 39 (UPDATE -> T .)
    GT              reduce using rule 39 (UPDATE -> T .)
    LT              reduce using rule 39 (UPDATE -> T .)
    EQ              reduce using rule 39 (UPDATE -> T .)
    PLUS            reduce using rule 39 (UPDATE -> T .)
    MINUS           reduce using rule 39 (UPDATE -> T .)
    OR              reduce using rule 39 (UPDATE -> T .)
    COLON           reduce using rule 39 (UPDATE -> T .)
    FOR             reduce using rule 39 (UPDATE -> T .)
    DO              reduce using rule 39 (UPDATE -> T .)
    GOSUB           reduce using rule 39 (UPDATE -> T .)
    PRINT           reduce using rule 39 (UPDATE -> T .)
    INPUT           reduce using rule 39 (UPDATE -> T .)
    IF              reduce using rule 39 (UPDATE -> T .)
    WHILE           reduce using rule 39 (UPDATE -> T .)
    NUMBER          reduce using rule 39 (UPDATE -> T .)
    ID              reduce using rule 39 (UPDATE -> T .)
    END             reduce using rule 39 (UPDATE -> T .)
    ENDP            reduce using rule 39 (UPDATE -> T .)
    DWHILE          reduce using rule 39 (UPDATE -> T .)
    ENDIF           reduce using rule 39 (UPDATE -> T .)
    ELSE            reduce using rule 39 (UPDATE -> T .)
    ENDW            reduce using rule 39 (UPDATE -> T .)
    ENDF            reduce using rule 39 (UPDATE -> T .)
    PARR            reduce using rule 39 (UPDATE -> T .)
    ENDDO           reduce using rule 39 (UPDATE -> T .)
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85


state 58

    (43) T -> F .

    TIMES           reduce using rule 43 (T -> F .)
    DIVIDE          reduce using rule 43 (T -> F .)
    AND             reduce using rule 43 (T -> F .)
    NE              reduce using rule 43 (T -> F .)
    GT              reduce using rule 43 (T -> F .)
    LT              reduce using rule 43 (T -> F .)
    EQ              reduce using rule 43 (T -> F .)
    PLUS            reduce using rule 43 (T -> F .)
    MINUS           reduce using rule 43 (T -> F .)
    OR              reduce using rule 43 (T -> F .)
    COLON           reduce using rule 43 (T -> F .)
    FOR             reduce using rule 43 (T -> F .)
    DO              reduce using rule 43 (T -> F .)
    GOSUB           reduce using rule 43 (T -> F .)
    PRINT           reduce using rule 43 (T -> F .)
    INPUT           reduce using rule 43 (T -> F .)
    IF              reduce using rule 43 (T -> F .)
    WHILE           reduce using rule 43 (T -> F .)
    NUMBER          reduce using rule 43 (T -> F .)
    ID              reduce using rule 43 (T -> F .)
    END             reduce using rule 43 (T -> F .)
    ENDP            reduce using rule 43 (T -> F .)
    DWHILE          reduce using rule 43 (T -> F .)
    ENDIF           reduce using rule 43 (T -> F .)
    ELSE            reduce using rule 43 (T -> F .)
    ENDW            reduce using rule 43 (T -> F .)
    ENDF            reduce using rule 43 (T -> F .)
    PARR            reduce using rule 43 (T -> F .)
    ENDDO           reduce using rule 43 (T -> F .)


state 59

    (47) F -> ID .

    TIMES           reduce using rule 47 (F -> ID .)
    DIVIDE          reduce using rule 47 (F -> ID .)
    AND             reduce using rule 47 (F -> ID .)
    NE              reduce using rule 47 (F -> ID .)
    GT              reduce using rule 47 (F -> ID .)
    LT              reduce using rule 47 (F -> ID .)
    EQ              reduce using rule 47 (F -> ID .)
    PLUS            reduce using rule 47 (F -> ID .)
    MINUS           reduce using rule 47 (F -> ID .)
    OR              reduce using rule 47 (F -> ID .)
    COLON           reduce using rule 47 (F -> ID .)
    FOR             reduce using rule 47 (F -> ID .)
    DO              reduce using rule 47 (F -> ID .)
    GOSUB           reduce using rule 47 (F -> ID .)
    PRINT           reduce using rule 47 (F -> ID .)
    INPUT           reduce using rule 47 (F -> ID .)
    IF              reduce using rule 47 (F -> ID .)
    WHILE           reduce using rule 47 (F -> ID .)
    NUMBER          reduce using rule 47 (F -> ID .)
    ID              reduce using rule 47 (F -> ID .)
    END             reduce using rule 47 (F -> ID .)
    ENDP            reduce using rule 47 (F -> ID .)
    DWHILE          reduce using rule 47 (F -> ID .)
    ENDIF           reduce using rule 47 (F -> ID .)
    ELSE            reduce using rule 47 (F -> ID .)
    ENDW            reduce using rule 47 (F -> ID .)
    ENDF            reduce using rule 47 (F -> ID .)
    PARR            reduce using rule 47 (F -> ID .)
    ENDDO           reduce using rule 47 (F -> ID .)


state 60

    (48) F -> NUMBER .

    TIMES           reduce using rule 48 (F -> NUMBER .)
    DIVIDE          reduce using rule 48 (F -> NUMBER .)
    AND             reduce using rule 48 (F -> NUMBER .)
    NE              reduce using rule 48 (F -> NUMBER .)
    GT              reduce using rule 48 (F -> NUMBER .)
    LT              reduce using rule 48 (F -> NUMBER .)
    EQ              reduce using rule 48 (F -> NUMBER .)
    PLUS            reduce using rule 48 (F -> NUMBER .)
    MINUS           reduce using rule 48 (F -> NUMBER .)
    OR              reduce using rule 48 (F -> NUMBER .)
    COLON           reduce using rule 48 (F -> NUMBER .)
    FOR             reduce using rule 48 (F -> NUMBER .)
    DO              reduce using rule 48 (F -> NUMBER .)
    GOSUB           reduce using rule 48 (F -> NUMBER .)
    PRINT           reduce using rule 48 (F -> NUMBER .)
    INPUT           reduce using rule 48 (F -> NUMBER .)
    IF              reduce using rule 48 (F -> NUMBER .)
    WHILE           reduce using rule 48 (F -> NUMBER .)
    NUMBER          reduce using rule 48 (F -> NUMBER .)
    ID              reduce using rule 48 (F -> NUMBER .)
    END             reduce using rule 48 (F -> NUMBER .)
    ENDP            reduce using rule 48 (F -> NUMBER .)
    DWHILE          reduce using rule 48 (F -> NUMBER .)
    ENDIF           reduce using rule 48 (F -> NUMBER .)
    ELSE            reduce using rule 48 (F -> NUMBER .)
    ENDW            reduce using rule 48 (F -> NUMBER .)
    ENDF            reduce using rule 48 (F -> NUMBER .)
    PARR            reduce using rule 48 (F -> NUMBER .)
    ENDDO           reduce using rule 48 (F -> NUMBER .)


state 61

    (49) F -> PARL . CONDITION PARR
    (57) CONDITION -> . UPDATE
    (58) CONDITION -> . UPDATE NE UPDATE
    (59) CONDITION -> . UPDATE GT UPDATE
    (60) CONDITION -> . UPDATE LT UPDATE
    (61) CONDITION -> . UPDATE EQ UPDATE
    (39) UPDATE -> . T
    (40) UPDATE -> . UPDATE PLUS T
    (41) UPDATE -> . UPDATE MINUS T
    (42) UPDATE -> . UPDATE OR T
    (43) T -> . F
    (44) T -> . T TIMES F
    (45) T -> . T DIVIDE F
    (46) T -> . T AND F
    (47) F -> . ID
    (48) F -> . NUMBER
    (49) F -> . PARL CONDITION PARR

    ID              shift and go to state 59
    NUMBER          shift and go to state 60
    PARL            shift and go to state 61

    CONDITION                      shift and go to state 86
    UPDATE                         shift and go to state 56
    T                              shift and go to state 57
    F                              shift and go to state 58

state 62

    (54) S -> WHILE AUXWHILE . CONDITION AUXCOLON ST AUXENDWHILE ENDW
    (57) CONDITION -> . UPDATE
    (58) CONDITION -> . UPDATE NE UPDATE
    (59) CONDITION -> . UPDATE GT UPDATE
    (60) CONDITION -> . UPDATE LT UPDATE
    (61) CONDITION -> . UPDATE EQ UPDATE
    (39) UPDATE -> . T
    (40) UPDATE -> . UPDATE PLUS T
    (41) UPDATE -> . UPDATE MINUS T
    (42) UPDATE -> . UPDATE OR T
    (43) T -> . F
    (44) T -> . T TIMES F
    (45) T -> . T DIVIDE F
    (46) T -> . T AND F
    (47) F -> . ID
    (48) F -> . NUMBER
    (49) F -> . PARL CONDITION PARR

    ID              shift and go to state 59
    NUMBER          shift and go to state 60
    PARL            shift and go to state 61

    CONDITION                      shift and go to state 87
    UPDATE                         shift and go to state 56
    T                              shift and go to state 57
    F                              shift and go to state 58

state 63

    (55) AUXWHILE -> empty .

    ID              reduce using rule 55 (AUXWHILE -> empty .)
    NUMBER          reduce using rule 55 (AUXWHILE -> empty .)
    PARL            reduce using rule 55 (AUXWHILE -> empty .)


state 64

    (14) P -> P AUXPOSP PROCEDURE ID COLON B . ENDP

    ENDP            shift and go to state 88


state 65

    (20) S -> FOR ID IN . ID COLON ST ENDF

    ID              shift and go to state 89


state 66

    (21) S -> DO COLON ST . DWHILE COLON CONDITION ENDDO

    DWHILE          shift and go to state 90


state 67

    (23) S -> PRINT PARL SID . PARR

    PARR            shift and go to state 91


state 68

    (24) SID -> STRING . SID2
    (26) SID2 -> . PLUS VMC SID2
    (27) SID2 -> . PLUS STRING SID2
    (28) SID2 -> . empty
    (63) empty -> .

    PLUS            shift and go to state 93
    PARR            reduce using rule 63 (empty -> .)

    SID2                           shift and go to state 92
    empty                          shift and go to state 94

state 69

    (25) SID -> VMC . SID2
    (26) SID2 -> . PLUS VMC SID2
    (27) SID2 -> . PLUS STRING SID2
    (28) SID2 -> . empty
    (63) empty -> .

    PLUS            shift and go to state 93
    PARR            reduce using rule 63 (empty -> .)

    SID2                           shift and go to state 95
    empty                          shift and go to state 94

state 70

    (29) VMC -> ID .
    (30) VMC -> ID . SQBL CMP SQBR SQBL CMP SQBR
    (31) VMC -> ID . SQBL CMP SQBR SQBL CMP SQBR SQBL CMP SQBR

    PLUS            reduce using rule 29 (VMC -> ID .)
    PARR            reduce using rule 29 (VMC -> ID .)
    COMMA           reduce using rule 29 (VMC -> ID .)
    SQBL            shift and go to state 96


state 71

    (34) S -> INPUT PARL IID . PARR

    PARR            shift and go to state 97


state 72

    (35) IID -> VMC . IID2
    (36) IID2 -> . COMMA VMC IID2
    (37) IID2 -> . empty
    (63) empty -> .

    COMMA           shift and go to state 99
    PARR            reduce using rule 63 (empty -> .)

    IID2                           shift and go to state 98
    empty                          shift and go to state 100

state 73

    (38) S -> CMP ASSIGN UPDATE .
    (40) UPDATE -> UPDATE . PLUS T
    (41) UPDATE -> UPDATE . MINUS T
    (42) UPDATE -> UPDATE . OR T

    FOR             reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    DO              reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    GOSUB           reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    PRINT           reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    INPUT           reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    IF              reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    WHILE           reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    NUMBER          reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    ID              reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    END             reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    ENDP            reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    DWHILE          reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    ENDIF           reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    ELSE            reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    ENDW            reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    ENDF            reduce using rule 38 (S -> CMP ASSIGN UPDATE .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    OR              shift and go to state 82


state 74

    (50) S -> IF CONDITION AUXCOLON . ST ENDIF
    (51) S -> IF CONDITION AUXCOLON . ST ELSE COLON AUXQ ST AUXENDIF ENDIF
    (18) ST -> . S ST
    (19) ST -> . empty
    (20) S -> . FOR ID IN ID COLON ST ENDF
    (21) S -> . DO COLON ST DWHILE COLON CONDITION ENDDO
    (22) S -> . GOSUB ID
    (23) S -> . PRINT PARL SID PARR
    (34) S -> . INPUT PARL IID PARR
    (38) S -> . CMP ASSIGN UPDATE
    (50) S -> . IF CONDITION AUXCOLON ST ENDIF
    (51) S -> . IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF
    (54) S -> . WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW
    (63) empty -> .
    (32) CMP -> . NUMBER
    (33) CMP -> . ID

    FOR             shift and go to state 36
    DO              shift and go to state 38
    GOSUB           shift and go to state 39
    PRINT           shift and go to state 40
    INPUT           shift and go to state 41
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    ENDIF           reduce using rule 63 (empty -> .)
    ELSE            reduce using rule 63 (empty -> .)
    NUMBER          shift and go to state 45
    ID              shift and go to state 37

    ST                             shift and go to state 101
    S                              shift and go to state 34
    empty                          shift and go to state 35
    CMP                            shift and go to state 42

state 75

    (62) AUXCOLON -> COLON .

    FOR             reduce using rule 62 (AUXCOLON -> COLON .)
    DO              reduce using rule 62 (AUXCOLON -> COLON .)
    GOSUB           reduce using rule 62 (AUXCOLON -> COLON .)
    PRINT           reduce using rule 62 (AUXCOLON -> COLON .)
    INPUT           reduce using rule 62 (AUXCOLON -> COLON .)
    IF              reduce using rule 62 (AUXCOLON -> COLON .)
    WHILE           reduce using rule 62 (AUXCOLON -> COLON .)
    NUMBER          reduce using rule 62 (AUXCOLON -> COLON .)
    ID              reduce using rule 62 (AUXCOLON -> COLON .)
    ENDIF           reduce using rule 62 (AUXCOLON -> COLON .)
    ELSE            reduce using rule 62 (AUXCOLON -> COLON .)
    ENDW            reduce using rule 62 (AUXCOLON -> COLON .)


state 76

    (58) CONDITION -> UPDATE NE . UPDATE
    (39) UPDATE -> . T
    (40) UPDATE -> . UPDATE PLUS T
    (41) UPDATE -> . UPDATE MINUS T
    (42) UPDATE -> . UPDATE OR T
    (43) T -> . F
    (44) T -> . T TIMES F
    (45) T -> . T DIVIDE F
    (46) T -> . T AND F
    (47) F -> . ID
    (48) F -> . NUMBER
    (49) F -> . PARL CONDITION PARR

    ID              shift and go to state 59
    NUMBER          shift and go to state 60
    PARL            shift and go to state 61

    UPDATE                         shift and go to state 102
    T                              shift and go to state 57
    F                              shift and go to state 58

state 77

    (59) CONDITION -> UPDATE GT . UPDATE
    (39) UPDATE -> . T
    (40) UPDATE -> . UPDATE PLUS T
    (41) UPDATE -> . UPDATE MINUS T
    (42) UPDATE -> . UPDATE OR T
    (43) T -> . F
    (44) T -> . T TIMES F
    (45) T -> . T DIVIDE F
    (46) T -> . T AND F
    (47) F -> . ID
    (48) F -> . NUMBER
    (49) F -> . PARL CONDITION PARR

    ID              shift and go to state 59
    NUMBER          shift and go to state 60
    PARL            shift and go to state 61

    UPDATE                         shift and go to state 103
    T                              shift and go to state 57
    F                              shift and go to state 58

state 78

    (60) CONDITION -> UPDATE LT . UPDATE
    (39) UPDATE -> . T
    (40) UPDATE -> . UPDATE PLUS T
    (41) UPDATE -> . UPDATE MINUS T
    (42) UPDATE -> . UPDATE OR T
    (43) T -> . F
    (44) T -> . T TIMES F
    (45) T -> . T DIVIDE F
    (46) T -> . T AND F
    (47) F -> . ID
    (48) F -> . NUMBER
    (49) F -> . PARL CONDITION PARR

    ID              shift and go to state 59
    NUMBER          shift and go to state 60
    PARL            shift and go to state 61

    UPDATE                         shift and go to state 104
    T                              shift and go to state 57
    F                              shift and go to state 58

state 79

    (61) CONDITION -> UPDATE EQ . UPDATE
    (39) UPDATE -> . T
    (40) UPDATE -> . UPDATE PLUS T
    (41) UPDATE -> . UPDATE MINUS T
    (42) UPDATE -> . UPDATE OR T
    (43) T -> . F
    (44) T -> . T TIMES F
    (45) T -> . T DIVIDE F
    (46) T -> . T AND F
    (47) F -> . ID
    (48) F -> . NUMBER
    (49) F -> . PARL CONDITION PARR

    ID              shift and go to state 59
    NUMBER          shift and go to state 60
    PARL            shift and go to state 61

    UPDATE                         shift and go to state 105
    T                              shift and go to state 57
    F                              shift and go to state 58

state 80

    (40) UPDATE -> UPDATE PLUS . T
    (43) T -> . F
    (44) T -> . T TIMES F
    (45) T -> . T DIVIDE F
    (46) T -> . T AND F
    (47) F -> . ID
    (48) F -> . NUMBER
    (49) F -> . PARL CONDITION PARR

    ID              shift and go to state 59
    NUMBER          shift and go to state 60
    PARL            shift and go to state 61

    T                              shift and go to state 106
    F                              shift and go to state 58

state 81

    (41) UPDATE -> UPDATE MINUS . T
    (43) T -> . F
    (44) T -> . T TIMES F
    (45) T -> . T DIVIDE F
    (46) T -> . T AND F
    (47) F -> . ID
    (48) F -> . NUMBER
    (49) F -> . PARL CONDITION PARR

    ID              shift and go to state 59
    NUMBER          shift and go to state 60
    PARL            shift and go to state 61

    T                              shift and go to state 107
    F                              shift and go to state 58

state 82

    (42) UPDATE -> UPDATE OR . T
    (43) T -> . F
    (44) T -> . T TIMES F
    (45) T -> . T DIVIDE F
    (46) T -> . T AND F
    (47) F -> . ID
    (48) F -> . NUMBER
    (49) F -> . PARL CONDITION PARR

    ID              shift and go to state 59
    NUMBER          shift and go to state 60
    PARL            shift and go to state 61

    T                              shift and go to state 108
    F                              shift and go to state 58

state 83

    (44) T -> T TIMES . F
    (47) F -> . ID
    (48) F -> . NUMBER
    (49) F -> . PARL CONDITION PARR

    ID              shift and go to state 59
    NUMBER          shift and go to state 60
    PARL            shift and go to state 61

    F                              shift and go to state 109

state 84

    (45) T -> T DIVIDE . F
    (47) F -> . ID
    (48) F -> . NUMBER
    (49) F -> . PARL CONDITION PARR

    ID              shift and go to state 59
    NUMBER          shift and go to state 60
    PARL            shift and go to state 61

    F                              shift and go to state 110

state 85

    (46) T -> T AND . F
    (47) F -> . ID
    (48) F -> . NUMBER
    (49) F -> . PARL CONDITION PARR

    ID              shift and go to state 59
    NUMBER          shift and go to state 60
    PARL            shift and go to state 61

    F                              shift and go to state 111

state 86

    (49) F -> PARL CONDITION . PARR

    PARR            shift and go to state 112


state 87

    (54) S -> WHILE AUXWHILE CONDITION . AUXCOLON ST AUXENDWHILE ENDW
    (62) AUXCOLON -> . COLON

    COLON           shift and go to state 75

    AUXCOLON                       shift and go to state 113

state 88

    (14) P -> P AUXPOSP PROCEDURE ID COLON B ENDP .

    BEGIN           reduce using rule 14 (P -> P AUXPOSP PROCEDURE ID COLON B ENDP .)
    PROCEDURE       reduce using rule 14 (P -> P AUXPOSP PROCEDURE ID COLON B ENDP .)


state 89

    (20) S -> FOR ID IN ID . COLON ST ENDF

    COLON           shift and go to state 114


state 90

    (21) S -> DO COLON ST DWHILE . COLON CONDITION ENDDO

    COLON           shift and go to state 115


state 91

    (23) S -> PRINT PARL SID PARR .

    FOR             reduce using rule 23 (S -> PRINT PARL SID PARR .)
    DO              reduce using rule 23 (S -> PRINT PARL SID PARR .)
    GOSUB           reduce using rule 23 (S -> PRINT PARL SID PARR .)
    PRINT           reduce using rule 23 (S -> PRINT PARL SID PARR .)
    INPUT           reduce using rule 23 (S -> PRINT PARL SID PARR .)
    IF              reduce using rule 23 (S -> PRINT PARL SID PARR .)
    WHILE           reduce using rule 23 (S -> PRINT PARL SID PARR .)
    NUMBER          reduce using rule 23 (S -> PRINT PARL SID PARR .)
    ID              reduce using rule 23 (S -> PRINT PARL SID PARR .)
    END             reduce using rule 23 (S -> PRINT PARL SID PARR .)
    ENDP            reduce using rule 23 (S -> PRINT PARL SID PARR .)
    DWHILE          reduce using rule 23 (S -> PRINT PARL SID PARR .)
    ENDIF           reduce using rule 23 (S -> PRINT PARL SID PARR .)
    ELSE            reduce using rule 23 (S -> PRINT PARL SID PARR .)
    ENDW            reduce using rule 23 (S -> PRINT PARL SID PARR .)
    ENDF            reduce using rule 23 (S -> PRINT PARL SID PARR .)


state 92

    (24) SID -> STRING SID2 .

    PARR            reduce using rule 24 (SID -> STRING SID2 .)


state 93

    (26) SID2 -> PLUS . VMC SID2
    (27) SID2 -> PLUS . STRING SID2
    (29) VMC -> . ID
    (30) VMC -> . ID SQBL CMP SQBR SQBL CMP SQBR
    (31) VMC -> . ID SQBL CMP SQBR SQBL CMP SQBR SQBL CMP SQBR

    STRING          shift and go to state 117
    ID              shift and go to state 70

    VMC                            shift and go to state 116

state 94

    (28) SID2 -> empty .

    PARR            reduce using rule 28 (SID2 -> empty .)


state 95

    (25) SID -> VMC SID2 .

    PARR            reduce using rule 25 (SID -> VMC SID2 .)


state 96

    (30) VMC -> ID SQBL . CMP SQBR SQBL CMP SQBR
    (31) VMC -> ID SQBL . CMP SQBR SQBL CMP SQBR SQBL CMP SQBR
    (32) CMP -> . NUMBER
    (33) CMP -> . ID

    NUMBER          shift and go to state 45
    ID              shift and go to state 37

    CMP                            shift and go to state 118

state 97

    (34) S -> INPUT PARL IID PARR .

    FOR             reduce using rule 34 (S -> INPUT PARL IID PARR .)
    DO              reduce using rule 34 (S -> INPUT PARL IID PARR .)
    GOSUB           reduce using rule 34 (S -> INPUT PARL IID PARR .)
    PRINT           reduce using rule 34 (S -> INPUT PARL IID PARR .)
    INPUT           reduce using rule 34 (S -> INPUT PARL IID PARR .)
    IF              reduce using rule 34 (S -> INPUT PARL IID PARR .)
    WHILE           reduce using rule 34 (S -> INPUT PARL IID PARR .)
    NUMBER          reduce using rule 34 (S -> INPUT PARL IID PARR .)
    ID              reduce using rule 34 (S -> INPUT PARL IID PARR .)
    END             reduce using rule 34 (S -> INPUT PARL IID PARR .)
    ENDP            reduce using rule 34 (S -> INPUT PARL IID PARR .)
    DWHILE          reduce using rule 34 (S -> INPUT PARL IID PARR .)
    ENDIF           reduce using rule 34 (S -> INPUT PARL IID PARR .)
    ELSE            reduce using rule 34 (S -> INPUT PARL IID PARR .)
    ENDW            reduce using rule 34 (S -> INPUT PARL IID PARR .)
    ENDF            reduce using rule 34 (S -> INPUT PARL IID PARR .)


state 98

    (35) IID -> VMC IID2 .

    PARR            reduce using rule 35 (IID -> VMC IID2 .)


state 99

    (36) IID2 -> COMMA . VMC IID2
    (29) VMC -> . ID
    (30) VMC -> . ID SQBL CMP SQBR SQBL CMP SQBR
    (31) VMC -> . ID SQBL CMP SQBR SQBL CMP SQBR SQBL CMP SQBR

    ID              shift and go to state 70

    VMC                            shift and go to state 119

state 100

    (37) IID2 -> empty .

    PARR            reduce using rule 37 (IID2 -> empty .)


state 101

    (50) S -> IF CONDITION AUXCOLON ST . ENDIF
    (51) S -> IF CONDITION AUXCOLON ST . ELSE COLON AUXQ ST AUXENDIF ENDIF

    ENDIF           shift and go to state 120
    ELSE            shift and go to state 121


state 102

    (58) CONDITION -> UPDATE NE UPDATE .
    (40) UPDATE -> UPDATE . PLUS T
    (41) UPDATE -> UPDATE . MINUS T
    (42) UPDATE -> UPDATE . OR T

    COLON           reduce using rule 58 (CONDITION -> UPDATE NE UPDATE .)
    PARR            reduce using rule 58 (CONDITION -> UPDATE NE UPDATE .)
    ENDDO           reduce using rule 58 (CONDITION -> UPDATE NE UPDATE .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    OR              shift and go to state 82


state 103

    (59) CONDITION -> UPDATE GT UPDATE .
    (40) UPDATE -> UPDATE . PLUS T
    (41) UPDATE -> UPDATE . MINUS T
    (42) UPDATE -> UPDATE . OR T

    COLON           reduce using rule 59 (CONDITION -> UPDATE GT UPDATE .)
    PARR            reduce using rule 59 (CONDITION -> UPDATE GT UPDATE .)
    ENDDO           reduce using rule 59 (CONDITION -> UPDATE GT UPDATE .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    OR              shift and go to state 82


state 104

    (60) CONDITION -> UPDATE LT UPDATE .
    (40) UPDATE -> UPDATE . PLUS T
    (41) UPDATE -> UPDATE . MINUS T
    (42) UPDATE -> UPDATE . OR T

    COLON           reduce using rule 60 (CONDITION -> UPDATE LT UPDATE .)
    PARR            reduce using rule 60 (CONDITION -> UPDATE LT UPDATE .)
    ENDDO           reduce using rule 60 (CONDITION -> UPDATE LT UPDATE .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    OR              shift and go to state 82


state 105

    (61) CONDITION -> UPDATE EQ UPDATE .
    (40) UPDATE -> UPDATE . PLUS T
    (41) UPDATE -> UPDATE . MINUS T
    (42) UPDATE -> UPDATE . OR T

    COLON           reduce using rule 61 (CONDITION -> UPDATE EQ UPDATE .)
    PARR            reduce using rule 61 (CONDITION -> UPDATE EQ UPDATE .)
    ENDDO           reduce using rule 61 (CONDITION -> UPDATE EQ UPDATE .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    OR              shift and go to state 82


state 106

    (40) UPDATE -> UPDATE PLUS T .
    (44) T -> T . TIMES F
    (45) T -> T . DIVIDE F
    (46) T -> T . AND F

    NE              reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    GT              reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    LT              reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    EQ              reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    PLUS            reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    MINUS           reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    OR              reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    COLON           reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    FOR             reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    DO              reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    GOSUB           reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    PRINT           reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    INPUT           reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    IF              reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    WHILE           reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    NUMBER          reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    ID              reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    END             reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    ENDP            reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    DWHILE          reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    ENDIF           reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    ELSE            reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    ENDW            reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    ENDF            reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    PARR            reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    ENDDO           reduce using rule 40 (UPDATE -> UPDATE PLUS T .)
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85


state 107

    (41) UPDATE -> UPDATE MINUS T .
    (44) T -> T . TIMES F
    (45) T -> T . DIVIDE F
    (46) T -> T . AND F

    NE              reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    GT              reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    LT              reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    EQ              reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    PLUS            reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    MINUS           reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    OR              reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    COLON           reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    FOR             reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    DO              reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    GOSUB           reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    PRINT           reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    INPUT           reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    IF              reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    WHILE           reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    NUMBER          reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    ID              reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    END             reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    ENDP            reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    DWHILE          reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    ENDIF           reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    ELSE            reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    ENDW            reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    ENDF            reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    PARR            reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    ENDDO           reduce using rule 41 (UPDATE -> UPDATE MINUS T .)
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85


state 108

    (42) UPDATE -> UPDATE OR T .
    (44) T -> T . TIMES F
    (45) T -> T . DIVIDE F
    (46) T -> T . AND F

    NE              reduce using rule 42 (UPDATE -> UPDATE OR T .)
    GT              reduce using rule 42 (UPDATE -> UPDATE OR T .)
    LT              reduce using rule 42 (UPDATE -> UPDATE OR T .)
    EQ              reduce using rule 42 (UPDATE -> UPDATE OR T .)
    PLUS            reduce using rule 42 (UPDATE -> UPDATE OR T .)
    MINUS           reduce using rule 42 (UPDATE -> UPDATE OR T .)
    OR              reduce using rule 42 (UPDATE -> UPDATE OR T .)
    COLON           reduce using rule 42 (UPDATE -> UPDATE OR T .)
    FOR             reduce using rule 42 (UPDATE -> UPDATE OR T .)
    DO              reduce using rule 42 (UPDATE -> UPDATE OR T .)
    GOSUB           reduce using rule 42 (UPDATE -> UPDATE OR T .)
    PRINT           reduce using rule 42 (UPDATE -> UPDATE OR T .)
    INPUT           reduce using rule 42 (UPDATE -> UPDATE OR T .)
    IF              reduce using rule 42 (UPDATE -> UPDATE OR T .)
    WHILE           reduce using rule 42 (UPDATE -> UPDATE OR T .)
    NUMBER          reduce using rule 42 (UPDATE -> UPDATE OR T .)
    ID              reduce using rule 42 (UPDATE -> UPDATE OR T .)
    END             reduce using rule 42 (UPDATE -> UPDATE OR T .)
    ENDP            reduce using rule 42 (UPDATE -> UPDATE OR T .)
    DWHILE          reduce using rule 42 (UPDATE -> UPDATE OR T .)
    ENDIF           reduce using rule 42 (UPDATE -> UPDATE OR T .)
    ELSE            reduce using rule 42 (UPDATE -> UPDATE OR T .)
    ENDW            reduce using rule 42 (UPDATE -> UPDATE OR T .)
    ENDF            reduce using rule 42 (UPDATE -> UPDATE OR T .)
    PARR            reduce using rule 42 (UPDATE -> UPDATE OR T .)
    ENDDO           reduce using rule 42 (UPDATE -> UPDATE OR T .)
    TIMES           shift and go to state 83
    DIVIDE          shift and go to state 84
    AND             shift and go to state 85


state 109

    (44) T -> T TIMES F .

    TIMES           reduce using rule 44 (T -> T TIMES F .)
    DIVIDE          reduce using rule 44 (T -> T TIMES F .)
    AND             reduce using rule 44 (T -> T TIMES F .)
    NE              reduce using rule 44 (T -> T TIMES F .)
    GT              reduce using rule 44 (T -> T TIMES F .)
    LT              reduce using rule 44 (T -> T TIMES F .)
    EQ              reduce using rule 44 (T -> T TIMES F .)
    PLUS            reduce using rule 44 (T -> T TIMES F .)
    MINUS           reduce using rule 44 (T -> T TIMES F .)
    OR              reduce using rule 44 (T -> T TIMES F .)
    COLON           reduce using rule 44 (T -> T TIMES F .)
    FOR             reduce using rule 44 (T -> T TIMES F .)
    DO              reduce using rule 44 (T -> T TIMES F .)
    GOSUB           reduce using rule 44 (T -> T TIMES F .)
    PRINT           reduce using rule 44 (T -> T TIMES F .)
    INPUT           reduce using rule 44 (T -> T TIMES F .)
    IF              reduce using rule 44 (T -> T TIMES F .)
    WHILE           reduce using rule 44 (T -> T TIMES F .)
    NUMBER          reduce using rule 44 (T -> T TIMES F .)
    ID              reduce using rule 44 (T -> T TIMES F .)
    END             reduce using rule 44 (T -> T TIMES F .)
    ENDP            reduce using rule 44 (T -> T TIMES F .)
    DWHILE          reduce using rule 44 (T -> T TIMES F .)
    ENDIF           reduce using rule 44 (T -> T TIMES F .)
    ELSE            reduce using rule 44 (T -> T TIMES F .)
    ENDW            reduce using rule 44 (T -> T TIMES F .)
    ENDF            reduce using rule 44 (T -> T TIMES F .)
    PARR            reduce using rule 44 (T -> T TIMES F .)
    ENDDO           reduce using rule 44 (T -> T TIMES F .)


state 110

    (45) T -> T DIVIDE F .

    TIMES           reduce using rule 45 (T -> T DIVIDE F .)
    DIVIDE          reduce using rule 45 (T -> T DIVIDE F .)
    AND             reduce using rule 45 (T -> T DIVIDE F .)
    NE              reduce using rule 45 (T -> T DIVIDE F .)
    GT              reduce using rule 45 (T -> T DIVIDE F .)
    LT              reduce using rule 45 (T -> T DIVIDE F .)
    EQ              reduce using rule 45 (T -> T DIVIDE F .)
    PLUS            reduce using rule 45 (T -> T DIVIDE F .)
    MINUS           reduce using rule 45 (T -> T DIVIDE F .)
    OR              reduce using rule 45 (T -> T DIVIDE F .)
    COLON           reduce using rule 45 (T -> T DIVIDE F .)
    FOR             reduce using rule 45 (T -> T DIVIDE F .)
    DO              reduce using rule 45 (T -> T DIVIDE F .)
    GOSUB           reduce using rule 45 (T -> T DIVIDE F .)
    PRINT           reduce using rule 45 (T -> T DIVIDE F .)
    INPUT           reduce using rule 45 (T -> T DIVIDE F .)
    IF              reduce using rule 45 (T -> T DIVIDE F .)
    WHILE           reduce using rule 45 (T -> T DIVIDE F .)
    NUMBER          reduce using rule 45 (T -> T DIVIDE F .)
    ID              reduce using rule 45 (T -> T DIVIDE F .)
    END             reduce using rule 45 (T -> T DIVIDE F .)
    ENDP            reduce using rule 45 (T -> T DIVIDE F .)
    DWHILE          reduce using rule 45 (T -> T DIVIDE F .)
    ENDIF           reduce using rule 45 (T -> T DIVIDE F .)
    ELSE            reduce using rule 45 (T -> T DIVIDE F .)
    ENDW            reduce using rule 45 (T -> T DIVIDE F .)
    ENDF            reduce using rule 45 (T -> T DIVIDE F .)
    PARR            reduce using rule 45 (T -> T DIVIDE F .)
    ENDDO           reduce using rule 45 (T -> T DIVIDE F .)


state 111

    (46) T -> T AND F .

    TIMES           reduce using rule 46 (T -> T AND F .)
    DIVIDE          reduce using rule 46 (T -> T AND F .)
    AND             reduce using rule 46 (T -> T AND F .)
    NE              reduce using rule 46 (T -> T AND F .)
    GT              reduce using rule 46 (T -> T AND F .)
    LT              reduce using rule 46 (T -> T AND F .)
    EQ              reduce using rule 46 (T -> T AND F .)
    PLUS            reduce using rule 46 (T -> T AND F .)
    MINUS           reduce using rule 46 (T -> T AND F .)
    OR              reduce using rule 46 (T -> T AND F .)
    COLON           reduce using rule 46 (T -> T AND F .)
    FOR             reduce using rule 46 (T -> T AND F .)
    DO              reduce using rule 46 (T -> T AND F .)
    GOSUB           reduce using rule 46 (T -> T AND F .)
    PRINT           reduce using rule 46 (T -> T AND F .)
    INPUT           reduce using rule 46 (T -> T AND F .)
    IF              reduce using rule 46 (T -> T AND F .)
    WHILE           reduce using rule 46 (T -> T AND F .)
    NUMBER          reduce using rule 46 (T -> T AND F .)
    ID              reduce using rule 46 (T -> T AND F .)
    END             reduce using rule 46 (T -> T AND F .)
    ENDP            reduce using rule 46 (T -> T AND F .)
    DWHILE          reduce using rule 46 (T -> T AND F .)
    ENDIF           reduce using rule 46 (T -> T AND F .)
    ELSE            reduce using rule 46 (T -> T AND F .)
    ENDW            reduce using rule 46 (T -> T AND F .)
    ENDF            reduce using rule 46 (T -> T AND F .)
    PARR            reduce using rule 46 (T -> T AND F .)
    ENDDO           reduce using rule 46 (T -> T AND F .)


state 112

    (49) F -> PARL CONDITION PARR .

    TIMES           reduce using rule 49 (F -> PARL CONDITION PARR .)
    DIVIDE          reduce using rule 49 (F -> PARL CONDITION PARR .)
    AND             reduce using rule 49 (F -> PARL CONDITION PARR .)
    NE              reduce using rule 49 (F -> PARL CONDITION PARR .)
    GT              reduce using rule 49 (F -> PARL CONDITION PARR .)
    LT              reduce using rule 49 (F -> PARL CONDITION PARR .)
    EQ              reduce using rule 49 (F -> PARL CONDITION PARR .)
    PLUS            reduce using rule 49 (F -> PARL CONDITION PARR .)
    MINUS           reduce using rule 49 (F -> PARL CONDITION PARR .)
    OR              reduce using rule 49 (F -> PARL CONDITION PARR .)
    COLON           reduce using rule 49 (F -> PARL CONDITION PARR .)
    FOR             reduce using rule 49 (F -> PARL CONDITION PARR .)
    DO              reduce using rule 49 (F -> PARL CONDITION PARR .)
    GOSUB           reduce using rule 49 (F -> PARL CONDITION PARR .)
    PRINT           reduce using rule 49 (F -> PARL CONDITION PARR .)
    INPUT           reduce using rule 49 (F -> PARL CONDITION PARR .)
    IF              reduce using rule 49 (F -> PARL CONDITION PARR .)
    WHILE           reduce using rule 49 (F -> PARL CONDITION PARR .)
    NUMBER          reduce using rule 49 (F -> PARL CONDITION PARR .)
    ID              reduce using rule 49 (F -> PARL CONDITION PARR .)
    END             reduce using rule 49 (F -> PARL CONDITION PARR .)
    ENDP            reduce using rule 49 (F -> PARL CONDITION PARR .)
    DWHILE          reduce using rule 49 (F -> PARL CONDITION PARR .)
    ENDIF           reduce using rule 49 (F -> PARL CONDITION PARR .)
    ELSE            reduce using rule 49 (F -> PARL CONDITION PARR .)
    ENDW            reduce using rule 49 (F -> PARL CONDITION PARR .)
    ENDF            reduce using rule 49 (F -> PARL CONDITION PARR .)
    PARR            reduce using rule 49 (F -> PARL CONDITION PARR .)
    ENDDO           reduce using rule 49 (F -> PARL CONDITION PARR .)


state 113

    (54) S -> WHILE AUXWHILE CONDITION AUXCOLON . ST AUXENDWHILE ENDW
    (18) ST -> . S ST
    (19) ST -> . empty
    (20) S -> . FOR ID IN ID COLON ST ENDF
    (21) S -> . DO COLON ST DWHILE COLON CONDITION ENDDO
    (22) S -> . GOSUB ID
    (23) S -> . PRINT PARL SID PARR
    (34) S -> . INPUT PARL IID PARR
    (38) S -> . CMP ASSIGN UPDATE
    (50) S -> . IF CONDITION AUXCOLON ST ENDIF
    (51) S -> . IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF
    (54) S -> . WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW
    (63) empty -> .
    (32) CMP -> . NUMBER
    (33) CMP -> . ID

    FOR             shift and go to state 36
    DO              shift and go to state 38
    GOSUB           shift and go to state 39
    PRINT           shift and go to state 40
    INPUT           shift and go to state 41
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    ENDW            reduce using rule 63 (empty -> .)
    NUMBER          shift and go to state 45
    ID              shift and go to state 37

    ST                             shift and go to state 122
    S                              shift and go to state 34
    empty                          shift and go to state 35
    CMP                            shift and go to state 42

state 114

    (20) S -> FOR ID IN ID COLON . ST ENDF
    (18) ST -> . S ST
    (19) ST -> . empty
    (20) S -> . FOR ID IN ID COLON ST ENDF
    (21) S -> . DO COLON ST DWHILE COLON CONDITION ENDDO
    (22) S -> . GOSUB ID
    (23) S -> . PRINT PARL SID PARR
    (34) S -> . INPUT PARL IID PARR
    (38) S -> . CMP ASSIGN UPDATE
    (50) S -> . IF CONDITION AUXCOLON ST ENDIF
    (51) S -> . IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF
    (54) S -> . WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW
    (63) empty -> .
    (32) CMP -> . NUMBER
    (33) CMP -> . ID

    FOR             shift and go to state 36
    DO              shift and go to state 38
    GOSUB           shift and go to state 39
    PRINT           shift and go to state 40
    INPUT           shift and go to state 41
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    ENDF            reduce using rule 63 (empty -> .)
    NUMBER          shift and go to state 45
    ID              shift and go to state 37

    ST                             shift and go to state 123
    S                              shift and go to state 34
    empty                          shift and go to state 35
    CMP                            shift and go to state 42

state 115

    (21) S -> DO COLON ST DWHILE COLON . CONDITION ENDDO
    (57) CONDITION -> . UPDATE
    (58) CONDITION -> . UPDATE NE UPDATE
    (59) CONDITION -> . UPDATE GT UPDATE
    (60) CONDITION -> . UPDATE LT UPDATE
    (61) CONDITION -> . UPDATE EQ UPDATE
    (39) UPDATE -> . T
    (40) UPDATE -> . UPDATE PLUS T
    (41) UPDATE -> . UPDATE MINUS T
    (42) UPDATE -> . UPDATE OR T
    (43) T -> . F
    (44) T -> . T TIMES F
    (45) T -> . T DIVIDE F
    (46) T -> . T AND F
    (47) F -> . ID
    (48) F -> . NUMBER
    (49) F -> . PARL CONDITION PARR

    ID              shift and go to state 59
    NUMBER          shift and go to state 60
    PARL            shift and go to state 61

    CONDITION                      shift and go to state 124
    UPDATE                         shift and go to state 56
    T                              shift and go to state 57
    F                              shift and go to state 58

state 116

    (26) SID2 -> PLUS VMC . SID2
    (26) SID2 -> . PLUS VMC SID2
    (27) SID2 -> . PLUS STRING SID2
    (28) SID2 -> . empty
    (63) empty -> .

    PLUS            shift and go to state 93
    PARR            reduce using rule 63 (empty -> .)

    SID2                           shift and go to state 125
    empty                          shift and go to state 94

state 117

    (27) SID2 -> PLUS STRING . SID2
    (26) SID2 -> . PLUS VMC SID2
    (27) SID2 -> . PLUS STRING SID2
    (28) SID2 -> . empty
    (63) empty -> .

    PLUS            shift and go to state 93
    PARR            reduce using rule 63 (empty -> .)

    SID2                           shift and go to state 126
    empty                          shift and go to state 94

state 118

    (30) VMC -> ID SQBL CMP . SQBR SQBL CMP SQBR
    (31) VMC -> ID SQBL CMP . SQBR SQBL CMP SQBR SQBL CMP SQBR

    SQBR            shift and go to state 127


state 119

    (36) IID2 -> COMMA VMC . IID2
    (36) IID2 -> . COMMA VMC IID2
    (37) IID2 -> . empty
    (63) empty -> .

    COMMA           shift and go to state 99
    PARR            reduce using rule 63 (empty -> .)

    IID2                           shift and go to state 128
    empty                          shift and go to state 100

state 120

    (50) S -> IF CONDITION AUXCOLON ST ENDIF .

    FOR             reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)
    DO              reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)
    GOSUB           reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)
    PRINT           reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)
    INPUT           reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)
    IF              reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)
    WHILE           reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)
    NUMBER          reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)
    ID              reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)
    END             reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)
    ENDP            reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)
    DWHILE          reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)
    ENDIF           reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)
    ELSE            reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)
    ENDW            reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)
    ENDF            reduce using rule 50 (S -> IF CONDITION AUXCOLON ST ENDIF .)


state 121

    (51) S -> IF CONDITION AUXCOLON ST ELSE . COLON AUXQ ST AUXENDIF ENDIF

    COLON           shift and go to state 129


state 122

    (54) S -> WHILE AUXWHILE CONDITION AUXCOLON ST . AUXENDWHILE ENDW
    (56) AUXENDWHILE -> . empty
    (63) empty -> .

    ENDW            reduce using rule 63 (empty -> .)

    AUXENDWHILE                    shift and go to state 130
    empty                          shift and go to state 131

state 123

    (20) S -> FOR ID IN ID COLON ST . ENDF

    ENDF            shift and go to state 132


state 124

    (21) S -> DO COLON ST DWHILE COLON CONDITION . ENDDO

    ENDDO           shift and go to state 133


state 125

    (26) SID2 -> PLUS VMC SID2 .

    PARR            reduce using rule 26 (SID2 -> PLUS VMC SID2 .)


state 126

    (27) SID2 -> PLUS STRING SID2 .

    PARR            reduce using rule 27 (SID2 -> PLUS STRING SID2 .)


state 127

    (30) VMC -> ID SQBL CMP SQBR . SQBL CMP SQBR
    (31) VMC -> ID SQBL CMP SQBR . SQBL CMP SQBR SQBL CMP SQBR

    SQBL            shift and go to state 134


state 128

    (36) IID2 -> COMMA VMC IID2 .

    PARR            reduce using rule 36 (IID2 -> COMMA VMC IID2 .)


state 129

    (51) S -> IF CONDITION AUXCOLON ST ELSE COLON . AUXQ ST AUXENDIF ENDIF
    (52) AUXQ -> . empty
    (63) empty -> .

    FOR             reduce using rule 63 (empty -> .)
    DO              reduce using rule 63 (empty -> .)
    GOSUB           reduce using rule 63 (empty -> .)
    PRINT           reduce using rule 63 (empty -> .)
    INPUT           reduce using rule 63 (empty -> .)
    IF              reduce using rule 63 (empty -> .)
    WHILE           reduce using rule 63 (empty -> .)
    NUMBER          reduce using rule 63 (empty -> .)
    ID              reduce using rule 63 (empty -> .)
    ENDIF           reduce using rule 63 (empty -> .)

    AUXQ                           shift and go to state 135
    empty                          shift and go to state 136

state 130

    (54) S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE . ENDW

    ENDW            shift and go to state 137


state 131

    (56) AUXENDWHILE -> empty .

    ENDW            reduce using rule 56 (AUXENDWHILE -> empty .)


state 132

    (20) S -> FOR ID IN ID COLON ST ENDF .

    FOR             reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)
    DO              reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)
    GOSUB           reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)
    PRINT           reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)
    INPUT           reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)
    IF              reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)
    WHILE           reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)
    NUMBER          reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)
    ID              reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)
    END             reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)
    ENDP            reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)
    DWHILE          reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)
    ENDIF           reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)
    ELSE            reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)
    ENDW            reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)
    ENDF            reduce using rule 20 (S -> FOR ID IN ID COLON ST ENDF .)


state 133

    (21) S -> DO COLON ST DWHILE COLON CONDITION ENDDO .

    FOR             reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)
    DO              reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)
    GOSUB           reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)
    PRINT           reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)
    INPUT           reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)
    IF              reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)
    WHILE           reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)
    NUMBER          reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)
    ID              reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)
    END             reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)
    ENDP            reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)
    DWHILE          reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)
    ENDIF           reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)
    ELSE            reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)
    ENDW            reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)
    ENDF            reduce using rule 21 (S -> DO COLON ST DWHILE COLON CONDITION ENDDO .)


state 134

    (30) VMC -> ID SQBL CMP SQBR SQBL . CMP SQBR
    (31) VMC -> ID SQBL CMP SQBR SQBL . CMP SQBR SQBL CMP SQBR
    (32) CMP -> . NUMBER
    (33) CMP -> . ID

    NUMBER          shift and go to state 45
    ID              shift and go to state 37

    CMP                            shift and go to state 138

state 135

    (51) S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ . ST AUXENDIF ENDIF
    (18) ST -> . S ST
    (19) ST -> . empty
    (20) S -> . FOR ID IN ID COLON ST ENDF
    (21) S -> . DO COLON ST DWHILE COLON CONDITION ENDDO
    (22) S -> . GOSUB ID
    (23) S -> . PRINT PARL SID PARR
    (34) S -> . INPUT PARL IID PARR
    (38) S -> . CMP ASSIGN UPDATE
    (50) S -> . IF CONDITION AUXCOLON ST ENDIF
    (51) S -> . IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF
    (54) S -> . WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW
    (63) empty -> .
    (32) CMP -> . NUMBER
    (33) CMP -> . ID

    FOR             shift and go to state 36
    DO              shift and go to state 38
    GOSUB           shift and go to state 39
    PRINT           shift and go to state 40
    INPUT           shift and go to state 41
    IF              shift and go to state 43
    WHILE           shift and go to state 44
    ENDIF           reduce using rule 63 (empty -> .)
    NUMBER          shift and go to state 45
    ID              shift and go to state 37

    ST                             shift and go to state 139
    S                              shift and go to state 34
    empty                          shift and go to state 35
    CMP                            shift and go to state 42

state 136

    (52) AUXQ -> empty .

    FOR             reduce using rule 52 (AUXQ -> empty .)
    DO              reduce using rule 52 (AUXQ -> empty .)
    GOSUB           reduce using rule 52 (AUXQ -> empty .)
    PRINT           reduce using rule 52 (AUXQ -> empty .)
    INPUT           reduce using rule 52 (AUXQ -> empty .)
    IF              reduce using rule 52 (AUXQ -> empty .)
    WHILE           reduce using rule 52 (AUXQ -> empty .)
    NUMBER          reduce using rule 52 (AUXQ -> empty .)
    ID              reduce using rule 52 (AUXQ -> empty .)
    ENDIF           reduce using rule 52 (AUXQ -> empty .)


state 137

    (54) S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .

    FOR             reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)
    DO              reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)
    GOSUB           reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)
    PRINT           reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)
    INPUT           reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)
    IF              reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)
    WHILE           reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)
    NUMBER          reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)
    ID              reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)
    END             reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)
    ENDP            reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)
    DWHILE          reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)
    ENDIF           reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)
    ELSE            reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)
    ENDW            reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)
    ENDF            reduce using rule 54 (S -> WHILE AUXWHILE CONDITION AUXCOLON ST AUXENDWHILE ENDW .)


state 138

    (30) VMC -> ID SQBL CMP SQBR SQBL CMP . SQBR
    (31) VMC -> ID SQBL CMP SQBR SQBL CMP . SQBR SQBL CMP SQBR

    SQBR            shift and go to state 140


state 139

    (51) S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST . AUXENDIF ENDIF
    (53) AUXENDIF -> . empty
    (63) empty -> .

    ENDIF           reduce using rule 63 (empty -> .)

    AUXENDIF                       shift and go to state 141
    empty                          shift and go to state 142

state 140

    (30) VMC -> ID SQBL CMP SQBR SQBL CMP SQBR .
    (31) VMC -> ID SQBL CMP SQBR SQBL CMP SQBR . SQBL CMP SQBR

    PLUS            reduce using rule 30 (VMC -> ID SQBL CMP SQBR SQBL CMP SQBR .)
    PARR            reduce using rule 30 (VMC -> ID SQBL CMP SQBR SQBL CMP SQBR .)
    COMMA           reduce using rule 30 (VMC -> ID SQBL CMP SQBR SQBL CMP SQBR .)
    SQBL            shift and go to state 143


state 141

    (51) S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF . ENDIF

    ENDIF           shift and go to state 144


state 142

    (53) AUXENDIF -> empty .

    ENDIF           reduce using rule 53 (AUXENDIF -> empty .)


state 143

    (31) VMC -> ID SQBL CMP SQBR SQBL CMP SQBR SQBL . CMP SQBR
    (32) CMP -> . NUMBER
    (33) CMP -> . ID

    NUMBER          shift and go to state 45
    ID              shift and go to state 37

    CMP                            shift and go to state 145

state 144

    (51) S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .

    FOR             reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)
    DO              reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)
    GOSUB           reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)
    PRINT           reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)
    INPUT           reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)
    IF              reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)
    WHILE           reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)
    NUMBER          reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)
    ID              reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)
    END             reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)
    ENDP            reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)
    DWHILE          reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)
    ENDIF           reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)
    ELSE            reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)
    ENDW            reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)
    ENDF            reduce using rule 51 (S -> IF CONDITION AUXCOLON ST ELSE COLON AUXQ ST AUXENDIF ENDIF .)


state 145

    (31) VMC -> ID SQBL CMP SQBR SQBL CMP SQBR SQBL CMP . SQBR

    SQBR            shift and go to state 146


state 146

    (31) VMC -> ID SQBL CMP SQBR SQBL CMP SQBR SQBL CMP SQBR .

    PLUS            reduce using rule 31 (VMC -> ID SQBL CMP SQBR SQBL CMP SQBR SQBL CMP SQBR .)
    PARR            reduce using rule 31 (VMC -> ID SQBL CMP SQBR SQBL CMP SQBR SQBL CMP SQBR .)
    COMMA           reduce using rule 31 (VMC -> ID SQBL CMP SQBR SQBL CMP SQBR SQBL CMP SQBR .)

